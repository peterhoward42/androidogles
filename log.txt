Android GL Play Around
----------------------

*  Get tutorial to work
*  Start afresh with copy to mess with keeping old as reference
*  Timeout for a second pass of studies
*  Get into github
*  Study and note git from first principles to be confident with branch usage
*  Tag the current commit as the official baseline
*  Make roadmap of ideas
*  Shaders from assets, retest, and commit
*  Dependency inject data for > 1 co-planar triangle
*  Have the camera transform change with time and add triangles out of plane
*  Have different bits of the model use different location transforms
o  Digress redisgn for lighting
    *  Decide input data structure for scene model - leave as is
    *  Convert back to drawArrays() with flat shading
    *  Do security check in
    *  Fix bug where not all faces shown
    *  Add in calculated face normals to triangle objects
    *  Convey face normals into vertex shader
    o  Digress to enable and check face culling
        o  When enabled should still render faces now
        o  If we reverse normals (or some) should all disappear
    o  Do and debug lighting calcs in vertex shader but don't use
        *  Timeout to get face culling working
        *  Shift new matrix stuff in mesher for cuboid into sensible places
        *  Timeout to make satellite rotate about Y axis as well as orbiting
        *  Do lighting calcs on paper
        *  Find out what good max and min colors are that are visible .2 to .8
        *  Feed global towards-light state into app
        *  Get this through to shader as a uniform
        *  Make color equal to light dirn to see if arriving
        *  Find out how to translate face normal into world space theoretically
        *  Decide how to split vMVP into sufficiently separate components so
           to do
           *  Don't need to split, just need to provide transform to convert
              vertex normals in model space into world space. 
           *  Call it modelToWorldNormalTrans
        *  Digress to split helpers into better named classes
        o  Split mMVP as above - with regression test
            *  Matrix helper - makeRotationsIsolatedTransform
            *  Convert the map returned by buildSiloRenderingMatrices to
               use RenderingTransforms objects as values, which have a property
               mvpTransform, and modelToWorldDirectionVectorTransform.
               *  code
               *  regression test
            *  Set the new field using trans factory.
            *  Use it once model to view trans known to capture normaltrans
        *  Rotate vertex normal into world space in vertex shader
            *  Provide uniform for model to world direction trans
        o  Have a go at proper lighting calcs
            *  Run?
            o  Correct light = no
                o  Look into unit tests
                    o  Nice and easy - finish relevant population
                        o  test transform factories by using them
                        o  make transformed triangle suspect
            o  Each face of main box should have differing colour, but
               unchanging.
            o  Satellite box faces should darken as they rotate
        o  Rationalise crossProduct and similar in xyzf
            o  Make float array native storage inside it, and expose as
               property
            o  Remove vector ops from xyzf into transform classes maybe
o  Try differing animation so faces turn away or towards light source
o  Try a cad generated source

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
Lighting calcs on paper
    o  Need towards-light direction vector in world space
    o  Need face normal rotated from model to world space
    o  Max dot product will be 1.0 when normal aligns with towards-light
    o  Dot will be zero when normal is perpendicular to towards-light
    o  Dot will be negative when normal faces to opposite half-sphere to that
       of light (but shouldn't get these if face culling is working)
    o  Desire max brightness when dot is 1.0
    o  Attenuating to ambient when dot is <= 0

-----------------------------------------------------------------------------
