Android GL Play Around
----------------------

*  Get tutorial to work
*  Start afresh with copy to mess with keeping old as reference
*  Timeout for a second pass of studies
*  Get into github
*  Study and note git from first principles to be confident with branch usage
*  Tag the current commit as the official baseline
*  Make roadmap of ideas
*  Shaders from assets, retest, and commit
*  Dependency inject data for > 1 co-planar triangle
*  Have the camera transform change with time and add triangles out of plane
*  Have different bits of the model use different location transforms
*  Digress redesign for lighting
*  Timeout strip all debug out
*  Create bit of package hierachy
*  Try a STL file source
*  Combine modelcollection with assembler into dynamic scene
*  Ditch num tri qry on dynamic scene - is duplicate of mesh api
*  Change name of qry on mesh from size to numberOfTriangles
*  Can we rename effective radius to make it clearer
*  Ditch blade stl for ip sake
*  More complex model
*  Fix Artefacts with cuter near and far setting
*  When project nice, tweak animation and position params for gears (will do)
*  Cuter content from grabcad that tests complexity
o  Interpolated normals
    *  Picture to be clear what want to do
    *  Design
    o  Do
        *  Decide tactics
        o  Define utilities needed
            *  RoundingHashForXYZf
            *  RoundingHashForMeshVertex
            o  Unit test hashes
                o  XYZf (coded)
                o  MeshVertex
            o  Vector deviation thresholder and unit test
        o  Add this func to existing Mesh class for build purposes and
           unit test build and pass. But don't consume it in render.
        o  Switch to consuming it in render.
        o  If all works - give triangle store to garbage collector.
o  We could now go back to using draw lists and not duplicate vertices,
   although vertices would have to be treated as unique if their normals
   differed.


o  Show part of camera frame / self
o  Performance limits

-----------------------------------------------------------------------------
Interpolating gradient
-----------------------------------------------------------------------------
    o  First rationalise winding order like now, and capture facet normal.
    o  Then for each vertex of each triangle, find all others triangles that
       share that vertex which pass a tangent continuity threshold test.
       Then ascribe to the first vertex, a normal that is the mean of all of
       the thus captured facet normals.
-----------------------------------------------------------------------------
Design
-----------------------------------------------------------------------------
    o  Triangle remains useful during construction, but better to get most
       software feeding of smarter mesh that defines triangles in terms
       of array of MeshVertex, whic encapsulates a XYZf for the position, but
       also another for the vertex normal. Noting that the same position will
       then sometimes exist > once to cater for differing normals.
-----------------------------------------------------------------------------
----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
----------------------------------------------------------------------------
